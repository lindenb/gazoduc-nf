{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Parabricks pipeline parameters",
  "$id": "https://raw.githubusercontent.com/gazoduc/master/nextflow_schema.json",
  "description": "Parabricks Pipeline",
  "type": "object",
  "$defs": {
    "input_and_output_params": {
      "title": "Input / Ouput",
      "type": "object",
      "description": "General Parameters",
      "required": ["fasta"],
      "properties": {
        "fasta": {
          "type": "string",
          "format": "file-path",
          "exists": true,
          "mimetype": "text/plain",
          "pattern": "^\\S+\\.(fasta|fa|fna)?(\\.gz)?$",
          "description": "Path to FASTA REFERENCE file.",
          "fa_icon": "far fa-file-code"
        },
        "prefix": {
          "type": "string",
          "pattern": "^[a-zA-z0-9_\\.]+\\.$",
          "description": "prefix for the save files. A good prefix would be 'YYYY-MM-DD.project_name.' ",
          "help_text": "Ouput file prefix"
        },

        "hts_type": {
          "type": "string",
          "pattern": "^(WES|WGS)$",
          "description": "Type of analysis (WES or WGS). If WES, --capture (bed) is expected.",
          "help_text": "Type of HTS analysis"
        },
        "bed": {
          "type": "string",
          "format": "file-path",
          "description": "Path to BED file that was used as the capture. Required for --hts_type=WES. For WGS a good idea is to make a BED excluding the hard-to-sequence regions (e.g: https://github.com/Boyle-Lab/Blacklist/  )",
          "help_text": "Capture BED"
        },
        "outdir": {
          "type": "string",
          "format": "directory-path",
          "description": "The output directory where the results will be saved. You have to use absolute paths to storage on Cloud infrastructure.",
          "help_text": "output directory",
          "fa_icon": "fas fa-folder-open"
        },
        "help": {
          "type": "boolean"
        }
      }
    },
    "mapping_fastqs": {
      "title": "Mapping FASTQs",
      "type": "object",
      "description": "Parameters use to map the reads on a reference genome.",
      "required": ["mapper"],
      "properties": {
        "samplesheet": {
          "type": "string",
          "format": "file-path",
          "exists": true,
          "mimetype": "text/plain",
          "pattern": "^\\S+\\.(csv|tsv|json)$",
          "description": "Path to samplesheet with the appropriate suffix (csv or tsv or json).<br/>For **ora** files or **fastq.gz** from illumina/dragen, the 'sample' column is optional as it can be extracted from the fastq name",
          "help_text": "path to fastq samplesheet."
        },
        "orad_directory": {
          "type": "string",
          "format": "directory-path",
          "description": "ora-d directory containing the sofwtare used to decrompress .ora files. If not defined, the toolbox is downloaded. (But on glicid it's blocked by the proxy)",
          "help_text": "path to ora-d directory used to decrompress .ora files."
        },
        "mapper": {
          "type": "string",
          "pattern": "^(bwa|pb|parabricks|dragmap)$",
          "description": "wich mapper to use. one of 'bwa,pb,parabricks,dragmap'"
        },
        "bwa_index_args": {
           "type": "string",
           "description":"extra parameters for bwa index. e.g. for option -b See: https://github.com/lh3/bwa/issues/104"
        },
        "known_indels_vcf":  {
          "type": "string",
          "pattern": "^\\S+\\.vcf\\.gz$",
          "description": "Path to  VCF indexed with tabix used as source of known indels for BQSR."
        },
        "with_merge_fastqs": {
          "type": "boolean",
          "description": "If true, merge the reads for the same sample. Always true for mapper=parabricks"
        },
        "with_fastp": {
          "type": "boolean",
          "description": "If true, preprocess the Reads with FASTP before mapping the reads"
        },
        
        "with_cram": {
          "type": "boolean",
          "description": "Save the alignments as CRAM (always true for parabricks)."
        },
        "bam2fastq_method" :{
           "type": "string",
           "pattern": "^(samtools|picard|gatk|pb|parabricks)$",
           "description":"when the input is a BAM/CRAM to has be converted back to fastq prior to mapping, what is the method to use ? "
        }
      }
    },
  "bam_qc_params": {
    "title": "QC for BAMs",
    "type": "object",
    "description": "Parameters used for BAM QC",
    "required": [],
    "properties": {
      "with_fastqc": {
          "type": "boolean",
          "description": "Run Fastqc. If --with_fastp==true, anothe fastqc is run after trimming."
        },
      "with_collect_metrics": {
        "type": "boolean",
          "description": "Run Picard Collect Metrics (which can be quite slow for WGS)."
        },
      "mosdepth_use_median":{
        "type": "boolean",
        "description":"use 'median' instead of 'average' to calculate the depth with mosdepth."
        },
      "mosdepth_min_depth":{
        "type": "number",
        "minimum": 0,
        "description":"Treshold of total mosdepth coverage. Bam below this treshold withh be affected by '--on_low_bam_quality'."
        },
      "on_low_bam_quality":{
        "type": "string",
        "pattern": "^(abort|warning|skip)$",
        "description":"What to do with BAMs with a depth under the treshold ? abort: stop the workflow. warning : just print a message. skip: skip the bams with a low quality."
        }
      }
    },
    "somalier_params": {
      "title": "SOMALIER",
      "type": "object",
      "description": "Parameters used for SOMALIER",
      "properties": {
        "with_somalier":{
          "type": "boolean",
          "description":"Run **somalier** on BAMs."
          },
        "somalier_vcf_sites": {
          "type": "string",
          "description":"somalier VCF sites. if ignored, VCF is downloaded ."
          }
        }
      },
      "manta_params": {
        "title": "MANTA",
        "type": "object",
        "description": "Manta: Structural variant and indel caller for mapped sequencing data  (https://github.com/Illumina/manta)",
        "properties": {
          "with_manta":{
            "type": "boolean",
            "description":"Run manta."
            },
          "with_truvari": {
            "type": "boolean",
            "description":"Apply truvari to merge the VCFs (https://github.com/ACEnglish/truvari)"
            }
          }
        },
      "smoove_params": {
        "title": "SMOOVE",
        "type": "object",
        "description": "Smoove: 'Structural variant calling and genotyping with existing tools, but, smoothly'.  https://github.com/brentp/smoove",
        "properties": {
          "with_smoove":{
            "type": "boolean",
            "description":"Run Smoove."
            }
          }
        },
     "delly_params": {
        "title": "DELLY2",
        "type": "object",
        "description": " DELLY2: Structural variant discovery by integrated paired-end and split-read analysis . https://github.com/dellytools/delly",
        "properties": {
          "with_delly":{
            "type": "boolean",
            "description":"Run DELLY2."
            }
          }
        },
     "indexcov_params": {
        "title": "INDEXCOV",
        "type": "object",
        "description": " Goleft/indexcov: Quickly estimate coverage from a whole-genome bam or cram index.  https://github.com/brentp/goleft/tree/master/indexcov/",
        "properties": {
          "with_indexcov":{
            "type": "boolean",
            "description":"Run Goleft/indexcov."
            },
          "indexcov_batchsize": {
            "type": "number",
            "minimum": 10,
            "description": "group BAMs by batch of 'x' bams. Useful when manupulating thousands of bams"
            }
          }
        },
     "cnvnator_params": {
        "title": "CNVnator",
        "type": "object",
        "description": "CNVnator: a tool for CNV discovery and genotyping from depth-of-coverage by mapped reads  : https://github.com/abyzovlab/CNVnator",
        "properties": {
          "with_cnvnator":{
            "type": "boolean",
            "description":"Run CNVnator"
            },
          "cnvnator_bin_size":{
            "type": "number",
            "minimum": 100,
            "description":"CNVnator 'bin' size"
            }
          }
        },
      "calling_params": {
        "title": "SNV Calling",
        "type": "object",
        "description": "General parameters for the SNV calling",
        "properties": {
          "makewindows_args":{
            "type": "string",
            "description":"Arguments for 'betools makewindows' Before calling the SNVs, the genome or the capture will be divided into smaller parts. For exome this parameter is quite useless unless the window size is lower than the fragment size. See also --bed_cluster_args2 "
            },
          "bed_cluster_args2":{
            "type": "string",
            "description":"Arguments for 'jvarkit bed cluster' group the fragments generated using --makewindows_args into bed file of size 'x'. For example for exomes, you can imagine grouping the fragments by group of 'x' bp. Used by graphtyper."
            },
          "exclude_encode_blacklist": {
            "type": "boolean",
            "description":"Exclude encode balcklist regions from the calling regions"
            }
          }
      },
     "graphtyper_params": {
        "title": "Graphtyper",
        "type": "object",
        "description": "Population-scale genotyping using pangenome graphs :  https://github.com/DecodeGenetics/graphtyper",
        "properties": {
          "with_graphtyper":{
            "type": "boolean",
            "description":"Run graphtyper"
            }
          }
        },
      "freebayes_params": {
        "title": "Freebayes",
        "type": "object",
        "description": "Freebayes :  Bayesian haplotype-based genetic polymorphism discovery and genotyping. https://github.com/freebayes/freebayes ",
        "properties": {
          "with_freebayes":{
            "type": "boolean",
            "description":"Run freebayes"
            },
          "freebayes_args":{
            "type": "string",
            "description":"extra parametes for freebayes"
            }
          }
        } ,
      "bcftools_params": {
        "title": "Bcftools",
        "type": "object",
        "description": "Bcftools  call variants with bcftools . https://github.com/samtools/bcftools ",
        "properties": {
          "with_bcftools_call":{
            "type": "boolean",
            "description":"Run bcftools call"
            }
          }
        } ,
      "haplotypcaller_params": {
        "title": "GATK HaplotypeCaller",
        "type": "object",
        "description": "GATK Haplotypecaller in GVCF mode. ",
        "properties": {
          "with_haplotype_caller":{
            "type": "boolean",
            "description":"Run GATK Haplotypcaller"
            },
          "hc_gvcf_merge_method": {
            "type": "string",
            "pattern": "^(combinegvcfs|glnexus)$",
            "description" : "Method to merge and genotype GVCF files ? 'combinegvcfs' or 'glnexus' "
            }
          }
        },
      "pb_deepvariant_params": {
        "title": "Parabricks DeepVariant",
        "type": "object",
        "description": "Deep Variant :  DeepVariant is an analysis pipeline that uses a deep neural network to call genetic variants from next-generation DNA sequencing data.  https://github.com/google/deepvariant",
        "properties": {
          "with_pb_deepvariant":{
            "type": "boolean",
            "description":"Run Parabricks DeepVariant"
            }
          }
        },
      "pb_haplotypecaller_params": {
        "title": "Parabricks HaplotypeCaller",
        "type": "object",
        "description": "Run the parabricks version of haplotypecaller.",
        "properties": {
          "with_pb_haplotypecaller":{
            "type": "boolean",
            "description":"Run Parabricks haplotypecaller"
            }
          }
        },
      "unmapped_params": {
        "title": "De Novo assembly of unmapped reads",
        "type": "object",
        "description": "Assemble unmapped reads with spades",
        "properties": {
          "with_unmapped":{
            "type": "boolean",
            "description":"try to assemble unmapped reads with spades"
            },
          "unmapped_fast_mode":{
            "type": "boolean",
            "description":"fast mode: use the last reads in the bam with unmapped ('*') chromosome. Slow mode: scan the whole bam, extracting discordant read in pairs where one read is unmapped."
            }
          }
        }
},
  "allOf": [
    { "$ref": "#/$defs/input_and_output_params" },
    { "$ref": "#/$defs/mapping_fastqs" },
    { "$ref": "#/$defs/bam_qc_params" },
    { "$ref": "#/$defs/somalier_params" },
    { "$ref": "#/$defs/manta_params" },
    { "$ref": "#/$defs/smoove_params" },
    { "$ref": "#/$defs/delly_params" },
    { "$ref": "#/$defs/indexcov_params" },
    { "$ref": "#/$defs/cnvnator_params" },
    { "$ref": "#/$defs/calling_params" },
    { "$ref": "#/$defs/graphtyper_params" },
    { "$ref": "#/$defs/freebayes_params" },
    { "$ref": "#/$defs/bcftools_params" },
    { "$ref": "#/$defs/haplotypcaller_params" },
    { "$ref": "#/$defs/pb_deepvariant_params" },
    { "$ref": "#/$defs/pb_haplotypecaller_params" },
    { "$ref": "#/$defs/unmapped_params" }
  ]
}
